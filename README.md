# CSI2P II Mini Project

## 介绍

让我们考虑一个 CPU，它有 32 位寄存器 `r0`-`r255` 和 256 字节的内存。

在这个项目中，你需要实现一个二进制表达式计算器。

## 输入

输入将包含几个由整数、运算符、括号和三个变量 `x`、`y` 和 `z` 组成的二进制表达式。

在这个项目中将出现以下运算符：

- `+`, `-`, `*`, `/`, `%`
- `=`
- `++`, `--`（包括前缀和后缀，如 `x++`，`--y`，等等）
- `+`, `-`（如 `+x`，`-y`，等等）
- 其他如 `>>`, `+=` 不可用且不会出现。

每个测试用例最多 15 行，每行 195 个字符。
- 也就是说，你不需要更改模板中定义的 `MAX_LENGTH` 的值。

## 输出

输出是汇编代码的列表。指令集架构列在下表中。

如果输入表达式包含非法表达式，你应该使用错误处理程序处理它。详情请参阅下面的 [**错误处理程序**](#error-handler)。

输入表达式是 C 表达式的子集，这意味着如果你正确初始化它们，你可以将输入视为 C 代码的一部分并获得 `x`、`y` 和 `z` 的相应值。你的汇编代码解决的 `x`、`y` 和 `z` 的结果应该与上述 C 代码的结果相同。

你可以参考 [**示例**](#sample) 部分查看示例。

## 指令集架构

### 内存操作

| 操作码 | 操作数1 | 操作数2 | 含义                                                    | 周期 |
| ------ | -------- | -------- | ---------------------------------------------------------- | ------ |
| load   | `reg`    | `[Addr]` | 从内存 `[Addr]` 加载数据并保存到寄存器 `reg` 中。 | 200    |
| store  | `[Addr]` | `reg`    | 将寄存器 `reg` 的数据存储到内存 `[Addr]` 中。     | 200    |

### 算术操作

| 操作码 | 操作数1 | 操作数2 | 操作数3 | 含义                                          | 周期 |
| ------ | -------- | -------- | -------- | ------------------------------------------------ | ------ |
| add    | `rd`     | `rs1`    | `rs2`    | 执行 `rs1+rs2` 并将结果保存到 `rd` 中。 | 10     |
| sub    | `rd`     | `rs1`    | `rs2`    | 执行 `rs1-rs2` 并将结果保存到 `rd` 中。 | 10     |
| mul    | `rd`     | `rs1`    | `rs2`    | 执行 `rs1*rs2` 并将结果保存到 `rd` 中。 | 30     |
| div    | `rd`     | `rs1`    | `rs2`    | 执行 `rs1/rs2` 并将结果保存到 `rd` 中。 | 50     |
| rem    | `rd`     | `rs1`    | `rs2`    | 执行 `rs1%rs2` 并将结果保存到 `rd` 中。 | 60     |

- 注意，`rs1` 和 `rs2` 都可以是寄存器或**非负整数**。但是，`rd` 必须是有效的寄存器。
- 所有操作数应以空格分隔。
- 使用前 8 个寄存器没有惩罚。然而，使用其他寄存器会使指令周期加倍。
  - 例如，`add r0 r1 r7` 花费 10 个周期，而 `add r8 r0 r23` 花费 20 个周期。

## 标识符

- 变量 `x`、`y` 和 `z` 的初始值分别存储在内存 `[0]`、`[4]` 和 `[8]` 中。在使用它们之前，你必须先将它们加载到寄存器中。
- 在汇编代码的评估之后，变量 `x`、`y` 和 `z` 的答案必须存储在内存 `[0]`、`[4]` 和 `[8]` 中。

## 语法

迷你项目的表达式语法。

从 "statement" 开始。

注意，这只检查语法错误，如 "x++++y"。然而，语义错误如 "5++" 或 "1=2+3" 将通过语法检查。

```
tokens:
    END:        ";"
    ASSIGN:     "="
    ADD:        "+"
    SUB:        "-"
    MUL:        "*"
    DIV:        "/"
    REM:        "%"
    PREINC:     "++"
    PREDEC:     "--"
    POSTINC:    "++"
    POSTDEC:    "--"
    PLUS:       "+"
    MINUS:      "-"
    IDENTIFIER: xyz
    CONSTANT:   123
    LPAR:       "("
    RPAR:       ")"

STMT
    → END
    | EXPR END
    ;
EXPR
    → ASSIGN_EXPR
    ;
ASSIGN_EXPR
    → ADD_EXPR
    | UNARY_EXPR ASSIGN ASSIGN_EXPR
    ;
ADD_EXPR
    → MUL_EXPR
    | ADD_EXPR ADD MUL_EXPR
    | ADD_EXPR SUB MUL_EXPR
    ;
MUL_EXPR
    → UNARY_EXPR
    | MUL_EXPR MUL UNARY_EXPR
    | MUL_EXPR DIV UNARY_EXPR
    | MUL_EXPR REM UNARY_EXPR
    ;
UNARY_EXPR
    → POSTFIX_EXPR
    | PREINC UNARY_EXPR
    | PREDEC UNARY_EXPR
    | PLUS UNARY_EXPR
    | MINUS UNARY_EXPR
    ;
POSTFIX_EXPR
    → PRI_EXPR
    | POSTFIX_EXPR POSTINC
    | POSTFIX_EXPR POSTDEC
    ;
PRI_EXPR
    → IDENTIFIER
    | CONSTANT
    | LPAR EXPR RPAR
    ;
```

## 错误处理程序

我们设计的表达式是 C 表达式语句的子集。也就是说：

- 如果这个表达式不能被 GCC 编译，它就是非法表达式。
- 我们的表达式不能拆分成多行，并且指令末尾必须有一个 `';'`。

非法表达式如：

- ```
  x = 5++;
  ```
- ```
  y = (((7/3);
  ```
- ```
  z = ++(y++);
  ```
- ```
  x = y 
    + 3;
  ```
- 以及所有不能通过 GCC 编译器的表达式都应该由错误处理程序处理。

当发生错误时，无论你的汇编代码输出了多少，你的输出**必须包含 `Compile Error!` 并换行**。

**注意，在我们的测试用例中，不会有任何未定义行为的表达式。** 如：

- 1/0（除以 0）
- x = x++（在一个表达式中多次更新变量）
- 2147483647+1（有符号溢出）
- 你可以通过使用 `-Wall` 标志编译一个 C 程序来检查表达式是否为未定义行为。如果是，应该会有一些警告显示 "undefined" 这个词，或者参考这个[网站](https://en.cppreference.com/w/cpp/language/ub)。

## 汇编编译器

ASMC - 汇编编译器，识别我们的 ISA 指令作为输入，然后解析它们并输出 x、y、z 的值和总 CPU 周期。输入应以 EOF 结束。

注意，ASMC 是用 C++ 编写的。

### 先决条件

支持标准版本 c++11 的 C++ 编译器。

### 编译

- 使用命令行

  运行命令：

  ```
  g++ -std=c++11 ASMC.cpp -o ASMC
  ```

  可执行文件将命名为 "ASMC"。

- 使用 codeblocks

  1. 使用 codeblocks 编译并执行。

### 指令

初始值 (x, y, z) 为 (2, 3, 5)。当错误或 EOF 发生时，x、y、z 的最终结果将显示出来。

**强烈建议你使用 ASMC 进行调试。**

使用命令行，你可以通过以下命令设置 x、y 和 z 的初始值：

```
./ASMC <x> <y> <z>
```

用它们的初始值替换 `<x>`、`<y>` 和 `<z>`。

## 示例

### 示例输入 1

```c
x = z + 5;
```

### 示例输出 1

```
load r0 [8]
add r1 0 5
add r0 r0 r1
store [0] r0
```

如果我们初始化 `(x,y,z)=(2,3,5)` 并将输入作为 C 代码的一部分执行以查看 `x`、`y` 和 `z` 的值，结果将是 `(x,y,z)=(10,3,5)`。

将输出输入到 ASMC，你将得到 `(x,y,z)=(10,3,5)` 的结果，这与上述结果相同，表明输出是正确的。

- 总周期成本：200（加载）+ 2*10（加法）+ 200（存储）= 420 周期。

### 示例输入 2

```c
x = (y++) + (++z);
z = ++(y++);
```

### 示例输出 2

```
load r255 [128]
Compile Error!
```

- 注意，在示例 2 中，第一个表达式是正确的，而第二个表达式导致编译错误（语义错误）。
- 编译错误测试用例的总周期将被视为 0。

### 示例输入 3

```c
7 + (x = (y = 3 * 5) % 9);
z = x * y;
z = 3;
```

### 示例输出 3

```
add r0 0 6
store [0] r0
add r0 0 15
store [4] r0
add r0 1 2
store [8] r0
```

- 你实际上不需要在每个表达式之后保持 `x`、`y` 和 `z`（即内存中的 `[0]`、`[4]` 和 `[8]`）的值正确，只要 `x`、`y` 和 `z` 的最终结果是正确的。
- 指令可以优化，这意味着你可以减少指令的数量，同时保持答案的正确性。

## 限制   

不允许使用 `itoa` 函数。请使用 `sprintf` 代替。

- 我们的评判系统是基于 Linux 的系统。`itoa` 不包含在标准库中。如果你调用 `itoa` 函数，你将收到编译错误。

## 评分

项目包括 2 部分：

1. **6 个基本测试用例**，由助教提供。
2. 比赛：演示时将有 **24 个测试用例**。前六个测试用例与基本测试用例相同。此外，总时钟周期**越少**的代码越好。前 10% 将**获得额外积分**。

我们将使用 ASMC 和我们的迷你项目实现来评判你的代码。

**如果你的程序在一个测试用例中运行超过 5 秒或内存使用超过 512MB，你将在该测试用例中得零分。**

