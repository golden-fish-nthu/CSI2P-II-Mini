# CSI2P II Mini Project

## 介紹

讓我們考慮一個 CPU，它有 32 位寄存器 `r0`-`r255` 和 256 字節的內存。

在這個項目中，你需要實現一個二進制表達式計算器。

## 輸入

輸入將包含幾個由整數、運算符、括號和三個變量 `x`、`y` 和 `z` 組成的二進制表達式。

在這個項目中將出現以下運算符：

- `+`, `-`, `*`, `/`, `%`
- `=`
- `++`, `--`（包括前綴和後綴，如 `x++`，`--y`，等等）
- `+`, `-`（如 `+x`，`-y`，等等）
- 其他如 `>>`, `+=` 不可用且不會出現。

每個測試用例最多 15 行，每行 195 個字符。
- 也就是說，你不需要更改模板中定義的 `MAX_LENGTH` 的值。

## 輸出

輸出是匯編代碼的列表。指令集架構列在下表中。

如果輸入表達式包含非法表達式，你應該使用錯誤處理程序處理它。詳情請參閱下面的 [**錯誤處理程序**](#錯誤處理程序)。

輸入表達式是 C 表達式的子集，這意味著如果你正確初始化它們，你可以將輸入視為 C 代碼的一部分並獲得 `x`、`y` 和 `z` 的相應值。你的匯編代碼解決的 `x`、`y` 和 `z` 的結果應該與上述 C 代碼的結果相同。

你可以參考 [**示例**](#示例) 部分查看示例。

## 指令集架構

### 內存操作

| 操作碼 | 操作數1 | 操作數2 | 含義                                                    | 周期 |
| ------ | -------- | -------- | ---------------------------------------------------------- | ------ |
| load   | `reg`    | `[Addr]` | 從內存 `[Addr]` 加載數據並保存到寄存器 `reg` 中。 | 200    |
| store  | `[Addr]` | `reg`    | 將寄存器 `reg` 的數據存儲到內存 `[Addr]` 中。     | 200    |

### 算術操作

| 操作碼 | 操作數1 | 操作數2 | 操作數3 | 含義                                          | 周期 |
| ------ | -------- | -------- | -------- | ------------------------------------------------ | ------ |
| add    | `rd`     | `rs1`    | `rs2`    | 執行 `rs1+rs2` 並將結果保存到 `rd` 中。 | 10     |
| sub    | `rd`     | `rs1`    | `rs2`    | 執行 `rs1-rs2` 並將結果保存到 `rd` 中。 | 10     |
| mul    | `rd`     | `rs1`    | `rs2`    | 執行 `rs1*rs2` 並將結果保存到 `rd` 中。 | 30     |
| div    | `rd`     | `rs1`    | `rs2`    | 執行 `rs1/rs2` 並將結果保存到 `rd` 中。 | 50     |
| rem    | `rd`     | `rs1`    | `rs2`    | 執行 `rs1%rs2` 並將結果保存到 `rd` 中。 | 60     |

- 注意，`rs1` 和 `rs2` 都可以是寄存器或**非負整數**。但是，`rd` 必須是有效的寄存器。
- 所有操作數應以空格分隔。
- 使用前 8 個寄存器沒有懲罰。然而，使用其他寄存器會使指令周期加倍。
  - 例如，`add r0 r1 r7` 花費 10 個周期，而 `add r8 r0 r23` 花費 20 個周期。

## 標識符

- 變量 `x`、`y` 和 `z` 的初始值分別存儲在內存 `[0]`、`[4]` 和 `[8]` 中。在使用它們之前，你必須先將它們加載到寄存器中。
- 在匯編代碼的評估之後，變量 `x`、`y` 和 `z` 的答案必須存儲在內存 `[0]`、`[4]` 和 `[8]` 中。

## 語法

迷你項目的表達式語法。

從 "statement" 開始。

注意，這只檢查語法錯誤，如 "x++++y"。然而，語義錯誤如 "5++" 或 "1=2+3" 將通過語法檢查。

```
tokens:
    END:        ";"
    ASSIGN:     "="
    ADD:        "+"
    SUB:        "-"
    MUL:        "*"
    DIV:        "/"
    REM:        "%"
    PREINC:     "++"
    PREDEC:     "--"
    POSTINC:    "++"
    POSTDEC:    "--"
    PLUS:       "+"
    MINUS:      "-"
    IDENTIFIER: xyz
    CONSTANT:   123
    LPAR:       "("
    RPAR:       ")"

STMT
    → END
    | EXPR END
    ;
EXPR
    → ASSIGN_EXPR
    ;
ASSIGN_EXPR
    → ADD_EXPR
    | UNARY_EXPR ASSIGN ASSIGN_EXPR
    ;
ADD_EXPR
    → MUL_EXPR
    | ADD_EXPR ADD MUL_EXPR
    | ADD_EXPR SUB MUL_EXPR
    ;
MUL_EXPR
    → UNARY_EXPR
    | MUL_EXPR MUL UNARY_EXPR
    | MUL_EXPR DIV UNARY_EXPR
    | MUL_EXPR REM UNARY_EXPR
    ;
UNARY_EXPR
    → POSTFIX_EXPR
    | PREINC UNARY_EXPR
    | PREDEC UNARY_EXPR
    | PLUS UNARY_EXPR
    | MINUS UNARY_EXPR
    ;
POSTFIX_EXPR
    → PRI_EXPR
    | POSTFIX_EXPR POSTINC
    | POSTFIX_EXPR POSTDEC
    ;
PRI_EXPR
    → IDENTIFIER
    | CONSTANT
    | LPAR EXPR RPAR
    ;
```

## 錯誤處理程序

我們設計的表達式是 C 表達式語句的子集。也就是說：

- 如果這個表達式不能被 GCC 編譯，它就是非法表達式。
- 我們的表達式不能拆分成多行，並且指令末尾必須有一個 `';'`。

非法表達式如：

- ```
  x = 5++;
  ```
- ```
  y = (((7/3);
  ```
- ```
  z = ++(y++);
  ```
- ```
  x = y 
    + 3;
  ```
- 以及所有不能通過 GCC 編譯器的表達式都應該由錯誤處理程序處理。

當發生錯誤時，無論你的匯編代碼輸出了多少，你的輸出**必須包含 `Compile Error!` 並換行**。

**注意，在我們的測試用例中，不會有任何未定義行為的表達式。** 如：

- 1/0（除以 0）
- x = x++（在一個表達式中多次更新變量）
- 2147483647+1（有符號溢出）
- 你可以通過使用 `-Wall` 標志編譯一個 C 程序來檢查表達式是否為未定義行為。如果是，應該會有一些警告顯示 "undefined" 這個詞，或者參考這個[網站](https://en.cppreference.com/w/cpp/language/ub)。

## 匯編編譯器

ASMC - 匯編編譯器，識別我們的 ISA 指令作為輸入，然後解析它們並輸出 x、y、z 的值和總 CPU 周期。輸入應以 EOF 結束。

注意，ASMC 是用 C++ 編寫的。

### 先決條件

支持標準版本 c++11 的 C++ 編譯器。

### 編譯

- 使用命令行

  運行命令：

  ```
  g++ -std=c++11 ASMC.cpp -o ASMC
  ```

  可執行文件將命名為 "ASMC"。

- 使用 codeblocks

  1. 使用 codeblocks 編譯並執行。

### 指令

初始值 (x, y, z) 為 (2, 3, 5)。當錯誤或 EOF 發生時，x、y、z 的最終結果將顯示出來。

**強烈建議你使用 ASMC 進行調試。**

使用命令行，你可以通過以下命令設置 x、y 和 z 的初始值：

```
./ASMC <x> <y> <z>
```

用它們的初始值替換 `<x>`、`<y>` 和 `<z>`。

## 示例

### 示例輸入 1

```c
x = z + 5;
```

### 示例輸出 1

```
load r0 [8]
add r1 0 5
add r0 r0 r1
store [0] r0
```

如果我們初始化 `(x,y,z)=(2,3,5)` 並將輸入作為 C 代碼的一部分執行以查看 `x`、`y` 和 `z` 的值，結果將是 `(x,y,z)=(10,3,5)`。

將輸出輸入到 ASMC，你將得到 `(x,y,z)=(10,3,5)` 的結果，這與上述結果相同，表明輸出是正確的。

- 總周期成本：200（加載）+ 2*10（加法）+ 200（存儲）= 420 周期。

### 示例輸入 2

```c
x = (y++) + (++z);
z = ++(y++);
```

### 示例輸出 2

```
load r255 [128]
Compile Error!
```

- 注意，在示例 2 中，第一個表達式是正確的，而第二個表達式導致編譯錯誤（語義錯誤）。
- 編譯錯誤測試用例的總周期將被視為 0。

### 示例輸入 3

```c
7 + (x = (y = 3 * 5) % 9);
z = x * y;
z = 3;
```

### 示例輸出 3

```
add r0 0 6
store [0] r0
add r0 0 15
store [4] r0
add r0 1 2
store [8] r0
```

- 你實際上不需要在每個表達式之後保持 `x`、`y` 和 `z`（即內存中的 `[0]`、`[4]` 和 `[8]`）的值正確，只要 `x`、`y` 和 `z` 的最終結果是正確的。
- 指令可以優化，這意味著你可以減少指令的數量，同時保持答案的正確性。

## 限制   

不允許使用 `itoa` 函數。請使用 `sprintf` 代替。

- 我們的評判系統是基於 Linux 的系統。`itoa` 不包含在標準庫中。如果你調用 `itoa` 函數，你將收到編譯錯誤。

## 評分

項目包括 2 部分：

1. **6 個基本測試用例**，由助教提供。
2. 比賽：演示時將有 **24 個測試用例**。前六個測試用例與基本測試用例相同。此外，總時鐘周期**越少**的代碼越好。前 10% 將**獲得額外積分**。

我們將使用 ASMC 和我們的迷你項目實現來評判你的代碼。

**如果你的程序在一個測試用例中運行超過 5 秒或內存使用超過 512MB，你將在該測試用例中得零分。**

